import cpw.mods.fml.client.*;
import cpw.mods.fml.client.registry.*;
import cpw.mods.fml.common.*;
import cpw.mods.fml.common.asm.*;
import cpw.mods.fml.common.asm.transformers.*;
import cpw.mods.fml.common.discovery.*;
import cpw.mods.fml.common.discovery.asm.*;
import cpw.mods.fml.common.event.*;
import cpw.mods.fml.common.functions.*;
import cpw.mods.fml.common.network.*;
import cpw.mods.fml.common.registry.*;
import cpw.mods.fml.common.toposort.*;
import cpw.mods.fml.common.versioning.*;
import cpw.mods.fml.relauncher.*;
import cpw.mods.fml.server.*;
import net.minecraft.block.*;
import net.minecraft.block.material.*;
import net.minecraft.client.*;
import net.minecraft.client.audio.*;
import net.minecraft.client.entity.*;
import net.minecraft.client.gui.*;
import net.minecraft.client.gui.achievement.*;
import net.minecraft.client.gui.inventory.*;
import net.minecraft.client.model.*;
import net.minecraft.client.multiplayer.*;
import net.minecraft.client.particle.*;
import net.minecraft.client.renderer.*;
import net.minecraft.client.renderer.culling.*;
import net.minecraft.client.renderer.entity.*;
import net.minecraft.client.renderer.tileentity.*;
import net.minecraft.client.settings.*;
import net.minecraft.command.*;
import net.minecraft.crash.*;
import net.minecraft.creativetab.*;
import net.minecraft.dispenser.*;
import net.minecraft.enchantment.*;
import net.minecraft.entity.*;
import net.minecraft.entity.ai.*;
import net.minecraft.entity.boss.*;
import net.minecraft.entity.effect.*;
import net.minecraft.entity.item.*;
import net.minecraft.entity.monster.*;
import net.minecraft.entity.passive.*;
import net.minecraft.entity.player.*;
import net.minecraft.entity.projectile.*;
import net.minecraft.inventory.*;
import net.minecraft.item.*;
import net.minecraft.item.crafting.*;
import net.minecraft.nbt.*;
import net.minecraft.network.*;
import net.minecraft.network.rcon.*;
import net.minecraft.pathfinding.*;
import net.minecraft.potion.*;
import net.minecraft.profiler.*;
import net.minecraft.server.*;
import net.minecraft.server.dedicated.*;
import net.minecraft.server.gui.*;
import net.minecraft.server.integrated.*;
import net.minecraft.server.management.*;
import net.minecraft.src.*;
import net.minecraft.stats.*;
import net.minecraft.tileentity.*;
import net.minecraft.util.*;
import net.minecraft.village.*;
import net.minecraft.world.*;
import net.minecraft.world.biome.*;
import net.minecraft.world.chunk.*;
import net.minecraft.world.chunk.storage.*;
import net.minecraft.world.demo.*;
import net.minecraft.world.gen.*;
import net.minecraft.world.gen.feature.*;
import net.minecraft.world.gen.layer.*;
import net.minecraft.world.gen.structure.*;
import net.minecraft.world.storage.*;
import net.minecraftforge.classloading.*;
import net.minecraftforge.client.*;
import net.minecraftforge.client.event.*;
import net.minecraftforge.client.event.sound.*;
import net.minecraftforge.common.*;
import net.minecraftforge.event.*;
import net.minecraftforge.event.entity.*;
import net.minecraftforge.event.entity.item.*;
import net.minecraftforge.event.entity.living.*;
import net.minecraftforge.event.entity.minecart.*;
import net.minecraftforge.event.entity.player.*;
import net.minecraftforge.event.terraingen.*;
import net.minecraftforge.event.world.*;
import net.minecraftforge.oredict.*;
import net.minecraftforge.transformers.*;
import net.minecraft.init.*;
import java.util.Random;

public class mcreator_%name% {

public mcreator_%name%(){}

public static Block%name% block2 = (Block%name%)(new Block%name%());
public static BlockModdedFire ModdedFire = (BlockModdedFire)new BlockModdedFire();
public static Item block = new Itemblock().setUnlocalizedName("%texture-flint%").setTextureName("%texture-flint%").setCreativeTab(CreativeTabs.tabTools);

public void load(){
DimensionManager.registerProviderType(%did%, WorldProvider%name%.class, false);
DimensionManager.registerDimension(%did%, %did%);
%load%
}

static{
	Item.itemRegistry.addObject(%iid%, "%texture-flint%", block);
	Blocks.blockRegistry.addObject(%bid1%, "%texture-flint%Portal", block2);
	Blocks.blockRegistry.addObject(%bid2%, "%texture-flint%Fire", ModdedFire);
}


static class Block%name% extends Block
{

int a1 = 0,a2 = 0,a3 = 0,a4 = 0,a5 = 0,a6 = 0;

IIcon gor = null, dol = null, st1 = null, st2 = null, st3 = null, st4 = null;

boolean red = false;





protected Block%name%()
{
        super(Material.ground);
        this.setTickRandomly(true);
		this.setHardness(-1.0F);
		this.setStepSound(soundGlassFootstep);
this.setLightValue(0.75F);

}

public Icon getIcon(int i, int par2){

if (i == 0)
return gor;

else if (i == 1)
return dol;

else if (i == 2)
return st1;

else if (i == 3)
return st2;

else if (i == 4)
return st4;

else if (i == 5)
return st3;

else
return gor;

}

public void registerIcons(IIconRegister par1IconRegister)
{
this.gor = par1IconRegister.registerIcon("%texture-portal%");
this.dol = par1IconRegister.registerIcon("%texture-portal%");
this.st1 = par1IconRegister.registerIcon("%texture-portal%");
this.st2 = par1IconRegister.registerIcon("%texture-portal%");
this.st3 = par1IconRegister.registerIcon("%texture-portal%");
this.st4 = par1IconRegister.registerIcon("%texture-portal%");
}

public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
{
super.updateTick(par1World, par2, par3, par4, par5Random);
if (par1World.provider.isSurfaceWorld() && par5Random.nextInt(2000) < par1World.difficultySetting)
{
int l;
for (l = par3; !par1World.doesBlockHaveSolidTopSurface(par2, l, par4) && l > 0; --l)
{
;
}
if (l > 0 && !par1World.isBlockNormalCube(par2, l + 1, par4))
{
Entity entity = ItemMonsterPlacer.spawnCreature(par1World, 57, (double)par2 + 0.5D, (double)l + 1.1D, (double)par4 + 0.5D);
if (entity != null)
{
         entity.timeUntilPortal = entity.getPortalCooldown();
}
}
}
}
/**
* Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
* cleared to be reused)
*/
public AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
{
return null;
}
/**
* Updates the blocks bounds based on its current state. Args: world, x, y, z
*/
public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
{
float f;
float f1;
if (par1IBlockAccess.getBlock(par2 - 1, par3, par4) != this && par1IBlockAccess.getBlock(par2 + 1, par3, par4) != this)
{
f = 0.125F;
f1 = 0.5F;
this.setBlockBounds(0.5F - f, 0.0F, 0.5F - f1, 0.5F + f, 1.0F, 0.5F + f1);
}
else
{
f = 0.5F;
f1 = 0.125F;
this.setBlockBounds(0.5F - f, 0.0F, 0.5F - f1, 0.5F + f, 1.0F, 0.5F + f1);
}
}
/**
* Is this block (a) opaque and (B) a full 1m cube? This determines whether or not to render the shared face of two
* adjacent blocks and also whether the player can attach torches, redstone wire, etc to this block.
*/
public boolean isOpaqueCube()
{
return false;
}
/**
* If this block doesn't render as an ordinary block it will return False (examples: signs, buttons, stairs, etc)
*/
@Override
public boolean renderAsNormalBlock()
{
return false;
}
/**
* Checks to see if this location is valid to create a portal and will return True if it does. Args: world, x, y, z
*/
public boolean tryToCreatePortal(World par1World, int par2, int par3, int par4)
{
byte b0 = 0;
byte b1 = 0;
if (par1World.getBlock(par2 - 1, par3, par4) == %frame-b% || par1World.getBlock(par2 + 1, par3, par4) == %frame-b%)
{
b0 = 1;
}
if (par1World.getBlock(par2, par3, par4 - 1) == %frame-b% || par1World.getBlock(par2, par3, par4 + 1) == %frame-b%)
{
b1 = 1;
}
if (b0 == b1)
{
return false;
}
else
{
if (par1World.getBlock(par2 - b0, par3, par4 - b1) == 0)
{
par2 -= b0;
par4 -= b1;
}
int l;
int i1;
for (l = -1; l <= 2; ++l)
{
for (i1 = -1; i1 <= 3; ++i1)
{
         boolean flag = l == -1 || l == 2 || i1 == -1 || i1 == 3;
         if (l != -1 && l != 2 || i1 != -1 && i1 != 3)
         {
         int j1 = par1World.getBlock(par2 + b0 * l, par3 + i1, par4 + b1 * l);
         if (flag)
         {
         if (j1 != %frame-b%)
         {
         return false;
         }
         }
         else if (j1 != 0 && j1 != ModdedFire)
         {
         return false;
         }
         }
}
}
for (l = 0; l < 2; ++l)
{
for (i1 = 0; i1 < 3; ++i1)
{
         par1World.setBlock(par2 + b0 * l, par3 + i1, par4 + b1 * l, block2, 0, 2);
}
}
return true;
}
}
/**
* Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
* their own) Args: x, y, z, neighbor blockID
*/
public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)
{
byte b0 = 0;
byte b1 = 1;
if (par1World.getBlock(par2 - 1, par3, par4) == this || par1World.getBlock(par2 + 1, par3, par4) == this)
{
b0 = 1;
b1 = 0;
}
int i1;
for (i1 = par3; par1World.getBlock(par2, i1 - 1, par4) == this; --i1)
{
;
}
if (par1World.getBlock(par2, i1 - 1, par4) != %frame-b%)
{
par1World.setBlockToAir(par2, par3, par4);
}
else
{
int j1;
for (j1 = 1; j1 < 4 && par1World.getBlock(par2, i1 + j1, par4) == this; ++j1)
{
;
}
if (j1 == 3 && par1World.getBlock(par2, i1 + j1, par4) == %frame-b%)
{
boolean flag = par1World.getBlock(par2 - 1, par3, par4) == this || par1World.getBlock(par2 + 1, par3, par4) == this;
boolean flag1 = par1World.getBlock(par2, par3, par4 - 1) == this || par1World.getBlock(par2, par3, par4 + 1) == this;
if (flag && flag1)
{
         par1World.setBlockToAir(par2, par3, par4);
}
else
{
         if ((par1World.getBlock(par2 + b0, par3, par4 + b1) != %frame-b% || par1World.getBlock(par2 - b0, par3, par4 - b1) != this) && (par1World.getBlock(par2 - b0, par3, par4 - b1) != %frame-b% || par1World.getBlock(par2 + b0, par3, par4 + b1) != this))
         {
         par1World.setBlockToAir(par2, par3, par4);
         }
}
}
else
{
par1World.setBlockToAir(par2, par3, par4);
}
}
}
@SideOnly(Side.CLIENT)
/**
* Returns true if the given side of this block type should be rendered, if the adjacent block is at the given
* coordinates. Args: blockAccess, x, y, z, side
*/
public boolean shouldSideBeRendered(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)
{
if (par1IBlockAccess.getBlock(par2, par3, par4) == this)
{
return false;
}
else
{
boolean flag = par1IBlockAccess.getBlock(par2 - 1, par3, par4) == this && par1IBlockAccess.getBlock(par2 - 2, par3, par4) != this;
boolean flag1 = par1IBlockAccess.getBlock(par2 + 1, par3, par4) == this && par1IBlockAccess.getBlock(par2 + 2, par3, par4) != this;
boolean flag2 = par1IBlockAccess.getBlock(par2, par3, par4 - 1) == this && par1IBlockAccess.getBlock(par2, par3, par4 - 2) != this;
boolean flag3 = par1IBlockAccess.getBlock(par2, par3, par4 + 1) == this && par1IBlockAccess.getBlock(par2, par3, par4 + 2) != this;
boolean flag4 = flag || flag1;
boolean flag5 = flag2 || flag3;
return flag4 && par5 == 4 ? true : (flag4 && par5 == 5 ? true : (flag5 && par5 == 2 ? true : flag5 && par5 == 3));
}
}
/**
* Returns the quantity of items to drop on block destruction.
*/
public int quantityDropped(Random par1Random)
{
return 0;
}
/**
* Triggered whenever an entity collides with this block (enters into the block). Args: world, x, y, z, entity
*/
public void onEntityCollidedWithBlock(World par1World, int par2, int par3, int par4, Entity par5Entity)
{
if ((par5Entity.ridingEntity == null) && (par5Entity.riddenByEntity == null) && ((par5Entity instanceof EntityPlayerMP)))
         {
         EntityPlayerMP thePlayer = (EntityPlayerMP)par5Entity;
         if (thePlayer.timeUntilPortal > 0)
         {
                 thePlayer.timeUntilPortal = 10;
         }
         else if (thePlayer.dimension != %did%)
         {
                 thePlayer.timeUntilPortal = 10;
                 thePlayer.mcServer.getConfigurationManager().transferPlayerToDimension(thePlayer, %did%, new ModdedTeleporter(thePlayer.mcServer.worldServerForDimension(%did%)));
         }
         else {
                 thePlayer.timeUntilPortal = 10;
                 thePlayer.mcServer.getConfigurationManager().transferPlayerToDimension(thePlayer, 0, new ModdedTeleporter(thePlayer.mcServer.worldServerForDimension(0)));
         }
         }
}
@SideOnly(Side.CLIENT)
/**
* Returns which pass should this block be rendered on. 0 for solids and 1 for alpha
*/
public int getRenderBlockPass()
{
return 1;
}
@SideOnly(Side.CLIENT)
/**
* A randomly called display update to be able to add particles or other items for display
*/
public void randomDisplayTick(World par1World, int par2, int par3, int par4, Random par5Random)
{
if (par5Random.nextInt(100) == 0)
{
par1World.playSound((double)par2 + 0.5D, (double)par3 + 0.5D, (double)par4 + 0.5D, "%portals%", 0.5F, par5Random.nextFloat() * 0.4F + 0.8F, false);
}
for (int l = 0; l < 4; ++l)
{
double d0 = (double)((float)par2 + par5Random.nextFloat());
double d1 = (double)((float)par3 + par5Random.nextFloat());
double d2 = (double)((float)par4 + par5Random.nextFloat());
double d3 = 0.0D;
double d4 = 0.0D;
double d5 = 0.0D;
int i1 = par5Random.nextInt(2) * 2 - 1;
d3 = ((double)par5Random.nextFloat() - 0.5D) * 0.5D;
d4 = ((double)par5Random.nextFloat() - 0.5D) * 0.5D;
d5 = ((double)par5Random.nextFloat() - 0.5D) * 0.5D;
if (par1World.getBlock(par2 - 1, par3, par4) != this && par1World.getBlock(par2 + 1, par3, par4) != this)
{
d0 = (double)par2 + 0.5D + 0.25D * (double)i1;
d3 = (double)(par5Random.nextFloat() * 2.0F * (float)i1);
}
else
{
d2 = (double)par4 + 0.5D + 0.25D * (double)i1;
d5 = (double)(par5Random.nextFloat() * 2.0F * (float)i1);
}
par1World.spawnParticle("%portalp%", d0, d1, d2, d3, d4, d5);
}
}
@SideOnly(Side.CLIENT)
/**
* only called by clickMiddleMouseButton , and passed to inventory.setCurrentItem (along with isCreative)
*/
public int idPicked(World par1World, int par2, int par3, int par4)
{
return 0;
}

}


public static class ModdedTeleporter extends Teleporter
{
private final WorldServer worldServerInstance;
/** A private Random() function in Teleporter */
private final Random random;
/** Stores successful portal placement locations for rapid lookup. */
private final LongHashMap destinationCoordinateCache = new LongHashMap();
/**
         * A list of valid keys for the destinationCoordainteCache. These are based on the X & Z of the players initial
         * location.
         */
private final List destinationCoordinateKeys = new ArrayList();
public ModdedTeleporter(WorldServer par1WorldServer)
{
         super(par1WorldServer);
         this.worldServerInstance = par1WorldServer;
         this.random = new Random(par1WorldServer.getSeed());
}
/**
         * Place an entity in a nearby portal, creating one if necessary.
         */
public void placeInPortal(Entity par1Entity, double par2, double par4, double par6, float par8)
{
         if (this.worldServerInstance.provider.dimensionId != 1)
         {
                 if (!this.placeInExistingPortal(par1Entity, par2, par4, par6, par8))
                 {
                         this.makePortal(par1Entity);
                         this.placeInExistingPortal(par1Entity, par2, par4, par6, par8);
                 }
         }
         else
         {
                 int i = MathHelper.floor_double(par1Entity.posX);
                 int j = MathHelper.floor_double(par1Entity.posY) - 1;
                 int k = MathHelper.floor_double(par1Entity.posZ);
                 byte b0 = 1;
                 byte b1 = 0;
                 for (int l = -2; l <= 2; ++l)
                 {
                         for (int i1 = -2; i1 <= 2; ++i1)
                         {
                                 for (int j1 = -1; j1 < 3; ++j1)
                                 {
                                         int k1 = i + i1 * b0 + l * b1;
                                         int l1 = j + j1;
                                         int i2 = k + i1 * b1 - l * b0;
                                         boolean flag = j1 < 0;

                                         /** change this block **/
                                         this.worldServerInstance.setBlock(k1, l1, i2, flag ? %frame-b% : 0);
                                 }
                         }
                 }
                 par1Entity.setLocationAndAngles((double)i, (double)j, (double)k, par1Entity.rotationYaw, 0.0F);
                 par1Entity.motionX = par1Entity.motionY = par1Entity.motionZ = 0.0D;
         }
}
/**
         * Place an entity in a nearby portal which already exists.
         */
public boolean placeInExistingPortal(Entity par1Entity, double par2, double par4, double par6, float par8)
{
         short short1 = 128;
         double d3 = -1.0D;
         int i = 0;
         int j = 0;
         int k = 0;
         int l = MathHelper.floor_double(par1Entity.posX);
         int i1 = MathHelper.floor_double(par1Entity.posZ);
         long j1 = ChunkCoordIntPair.chunkXZ2Int(l, i1);
         boolean flag = true;
         double d4;
         int k1;
         if (this.destinationCoordinateCache.containsItem(j1))
         {
                 PortalPosition portalposition = (PortalPosition)this.destinationCoordinateCache.getValueByKey(j1);
                 d3 = 0.0D;
                 i = portalposition.posX;
                 j = portalposition.posY;
                 k = portalposition.posZ;
                 portalposition.lastUpdateTime = this.worldServerInstance.getTotalWorldTime();
                 flag = false;
         }
         else
         {
                 for (k1 = l - short1; k1 <= l + short1; ++k1)
                 {
                         double d5 = (double)k1 + 0.5D - par1Entity.posX;
                         for (int l1 = i1 - short1; l1 <= i1 + short1; ++l1)
                         {
                                 double d6 = (double)l1 + 0.5D - par1Entity.posZ;
                                 for (int i2 = this.worldServerInstance.getActualHeight() - 1; i2 >= 0; --i2)
                                 {
                                         /** change this block **/
                                         if (this.worldServerInstance.getBlock(k1, i2, l1) == block2)
                                         {
                                                 /** change this block **/
                                                 while (this.worldServerInstance.getBlock(k1, i2 - 1, l1) == block2)
                                                 {
                                                         --i2;
                                                 }
                                                 d4 = (double)i2 + 0.5D - par1Entity.posY;
                                                 double d7 = d5 * d5 + d4 * d4 + d6 * d6;
                                                 if (d3 < 0.0D || d7 < d3)
                                                 {
                                                         d3 = d7;
                                                         i = k1;
                                                         j = i2;
                                                         k = l1;
                                                 }
                                         }
                                 }
                         }
                 }
         }
         if (d3 >= 0.0D)
         {
                 if (flag)
                 {
                         this.destinationCoordinateCache.add(j1, new ModdedPortalPosition(this, i, j, k, this.worldServerInstance.getTotalWorldTime()));
                         this.destinationCoordinateKeys.add(Long.valueOf(j1));
                 }
                 double d8 = (double)i + 0.5D;
                 double d9 = (double)j + 0.5D;
                 d4 = (double)k + 0.5D;
                 int j2 = -1;
                 /** change this block **/
                 if (this.worldServerInstance.getBlock(i - 1, j, k) == block2)
                 {
                         j2 = 2;
                 }
                 /** change this block **/
                 if (this.worldServerInstance.getBlock(i + 1, j, k) == block2)
                 {
                         j2 = 0;
                 }
                 /** change this block **/
                 if (this.worldServerInstance.getBlock(i, j, k - 1) == block2)
                 {
                         j2 = 3;
                 }
                 /** change this block **/
                 if (this.worldServerInstance.getBlock(i, j, k + 1) == block2)
                 {
                         j2 = 1;
                 }
                 int k2 = par1Entity.getTeleportDirection();
                 if (j2 > -1)
                 {
                         int l2 = Direction.rotateLeft[j2];
                         int i3 = Direction.offsetX[j2];
                         int j3 = Direction.offsetZ[j2];
                         int k3 = Direction.offsetX[l2];
                         int l3 = Direction.offsetZ[l2];
                         boolean flag1 = !this.worldServerInstance.isAirBlock(i + i3 + k3, j, k + j3 + l3) || !this.worldServerInstance.isAirBlock(i + i3 + k3, j + 1, k + j3 + l3);
                         boolean flag2 = !this.worldServerInstance.isAirBlock(i + i3, j, k + j3) || !this.worldServerInstance.isAirBlock(i + i3, j + 1, k + j3);
                         if (flag1 && flag2)
                         {
                                 j2 = Direction.rotateOpposite[j2];
                                 l2 = Direction.rotateOpposite[l2];
                                 i3 = Direction.offsetX[j2];
                                 j3 = Direction.offsetZ[j2];
                                 k3 = Direction.offsetX[l2];
                                 l3 = Direction.offsetZ[l2];
                                 k1 = i - k3;
                                 d8 -= (double)k3;
                                 int i4 = k - l3;
                                 d4 -= (double)l3;
                                 flag1 = !this.worldServerInstance.isAirBlock(k1 + i3 + k3, j, i4 + j3 + l3) || !this.worldServerInstance.isAirBlock(k1 + i3 + k3, j + 1, i4 + j3 + l3);
                                 flag2 = !this.worldServerInstance.isAirBlock(k1 + i3, j, i4 + j3) || !this.worldServerInstance.isAirBlock(k1 + i3, j + 1, i4 + j3);
                         }
                         float f1 = 0.5F;
                         float f2 = 0.5F;
                         if (!flag1 && flag2)
                         {
                                 f1 = 1.0F;
                         }
                         else if (flag1 && !flag2)
                         {
                                 f1 = 0.0F;
                         }
                         else if (flag1 && flag2)
                         {
                                 f2 = 0.0F;
                         }
                         d8 += (double)((float)k3 * f1 + f2 * (float)i3);
                         d4 += (double)((float)l3 * f1 + f2 * (float)j3);
                         float f3 = 0.0F;
                         float f4 = 0.0F;
                         float f5 = 0.0F;
                         float f6 = 0.0F;
                         if (j2 == k2)
                         {
                                 f3 = 1.0F;
                                 f4 = 1.0F;
                         }
                         else if (j2 == Direction.rotateOpposite[k2])
                         {
                                 f3 = -1.0F;
                                 f4 = -1.0F;
                         }
                         else if (j2 == Direction.rotateRight[k2])
                         {
                                 f5 = 1.0F;
                                 f6 = -1.0F;
                         }
                         else
                         {
                                 f5 = -1.0F;
                                 f6 = 1.0F;
                         }
                         double d10 = par1Entity.motionX;
                         double d11 = par1Entity.motionZ;
                         par1Entity.motionX = d10 * (double)f3 + d11 * (double)f6;
                         par1Entity.motionZ = d10 * (double)f5 + d11 * (double)f4;
                         par1Entity.rotationYaw = par8 - (float)(k2 * 90) + (float)(j2 * 90);
                 }
                 else
                 {
                         par1Entity.motionX = par1Entity.motionY = par1Entity.motionZ = 0.0D;
                 }
                 par1Entity.setLocationAndAngles(d8, d9, d4, par1Entity.rotationYaw, par1Entity.rotationPitch);
                 return true;
         }
         else
         {
                 return false;
         }
}
public boolean makePortal(Entity par1Entity)
{
         byte b0 = 16;
         double d0 = -1.0D;
         int i = MathHelper.floor_double(par1Entity.posX);
         int j = MathHelper.floor_double(par1Entity.posY);
         int k = MathHelper.floor_double(par1Entity.posZ);
         int l = i;
         int i1 = j;
         int j1 = k;
         int k1 = 0;
         int l1 = this.random.nextInt(4);
         int i2;
         double d1;
         double d2;
         int j2;
         int k2;
         int l2;
         int i3;
         int j3;
         int k3;
         int l3;
         int i4;
         int j4;
         int k4;
         double d3;
         double d4;
         for (i2 = i - b0; i2 <= i + b0; ++i2)
         {
                 d1 = (double)i2 + 0.5D - par1Entity.posX;
                 for (j2 = k - b0; j2 <= k + b0; ++j2)
                 {
                         d2 = (double)j2 + 0.5D - par1Entity.posZ;
                         label274:
                         for (k2 = this.worldServerInstance.getActualHeight() - 1; k2 >= 0; --k2)
                         {
                                 if (this.worldServerInstance.isAirBlock(i2, k2, j2))
                                 {
                                         while (k2 > 0 && this.worldServerInstance.isAirBlock(i2, k2 - 1, j2))
                                         {
                                                 --k2;
                                         }
                                         for (i3 = l1; i3 < l1 + 4; ++i3)
                                         {
                                                 l2 = i3 % 2;
                                                 k3 = 1 - l2;
                                                 if (i3 % 4 >= 2)
                                                 {
                                                         l2 = -l2;
                                                         k3 = -k3;
                                                 }
                                                 for (j3 = 0; j3 < 3; ++j3)
                                                 {
                                                         for (i4 = 0; i4 < 4; ++i4)
                                                         {
                                                                 for (l3 = -1; l3 < 4; ++l3)
                                                                 {
                                                                         k4 = i2 + (i4 - 1) * l2 + j3 * k3;
                                                                         j4 = k2 + l3;
                                                                         int l4 = j2 + (i4 - 1) * k3 - j3 * l2;
                                                                         if (l3 < 0 && !this.worldServerInstance.getBlockMaterial(k4, j4, l4).isSolid() || l3 >= 0 && !this.worldServerInstance.isAirBlock(k4, j4, l4))
                                                                         {
                                                                                 continue label274;
                                                                         }
                                                                 }
                                                         }
                                                 }
                                                 d4 = (double)k2 + 0.5D - par1Entity.posY;
                                                 d3 = d1 * d1 + d4 * d4 + d2 * d2;
                                                 if (d0 < 0.0D || d3 < d0)
                                                 {
                                                         d0 = d3;
                                                         l = i2;
                                                         i1 = k2;
                                                         j1 = j2;
                                                         k1 = i3 % 4;
                                                 }
                                         }
                                 }
                         }
                 }
         }
         if (d0 < 0.0D)
         {
                 for (i2 = i - b0; i2 <= i + b0; ++i2)
                 {
                         d1 = (double)i2 + 0.5D - par1Entity.posX;
                         for (j2 = k - b0; j2 <= k + b0; ++j2)
                         {
                                 d2 = (double)j2 + 0.5D - par1Entity.posZ;
                                 label222:
                                 for (k2 = this.worldServerInstance.getActualHeight() - 1; k2 >= 0; --k2)
                                 {
                                         if (this.worldServerInstance.isAirBlock(i2, k2, j2))
                                         {
                                                 while (k2 > 0 && this.worldServerInstance.isAirBlock(i2, k2 - 1, j2))
                                                 {
                                                         --k2;
                                                 }
                                                 for (i3 = l1; i3 < l1 + 2; ++i3)
                                                 {
                                                         l2 = i3 % 2;
                                                         k3 = 1 - l2;
                                                         for (j3 = 0; j3 < 4; ++j3)
                                                         {
                                                                 for (i4 = -1; i4 < 4; ++i4)
                                                                 {
                                                                         l3 = i2 + (j3 - 1) * l2;
                                                                         k4 = k2 + i4;
                                                                         j4 = j2 + (j3 - 1) * k3;
                                                                         if (i4 < 0 && !this.worldServerInstance.getBlockMaterial(l3, k4, j4).isSolid() || i4 >= 0 && !this.worldServerInstance.isAirBlock(l3, k4, j4))
                                                                         {
                                                                                 continue label222;
                                                                         }
                                                                 }
                                                         }
                                                         d4 = (double)k2 + 0.5D - par1Entity.posY;
                                                         d3 = d1 * d1 + d4 * d4 + d2 * d2;
                                                         if (d0 < 0.0D || d3 < d0)
                                                         {
                                                                 d0 = d3;
                                                                 l = i2;
                                                                 i1 = k2;
                                                                 j1 = j2;
                                                                 k1 = i3 % 2;
                                                         }
                                                 }
                                         }
                                 }
                         }
                 }
         }
         int i5 = l;
         int j5 = i1;
         j2 = j1;
         int k5 = k1 % 2;
         int l5 = 1 - k5;
         if (k1 % 4 >= 2)
         {
                 k5 = -k5;
                 l5 = -l5;
         }
         boolean flag;
         if (d0 < 0.0D)
         {
                 if (i1 < 70)
                 {
                         i1 = 70;
                 }
                 if (i1 > this.worldServerInstance.getActualHeight() - 10)
                 {
                         i1 = this.worldServerInstance.getActualHeight() - 10;
                 }
                 j5 = i1;
                 for (k2 = -1; k2 <= 1; ++k2)
                 {
                         for (i3 = 1; i3 < 3; ++i3)
                         {
                                 for (l2 = -1; l2 < 3; ++l2)
                                 {
                                         k3 = i5 + (i3 - 1) * k5 + k2 * l5;
                                         j3 = j5 + l2;
                                         i4 = j2 + (i3 - 1) * l5 - k2 * k5;
                                         flag = l2 < 0;

                                         /** change this block **/
                                         this.worldServerInstance.setBlock(k3, j3, i4, flag ? %frame-b% : 0);
                                 }
                         }
                 }
         }
         for (k2 = 0; k2 < 4; ++k2)
         {
                 for (i3 = 0; i3 < 4; ++i3)
                 {
                         for (l2 = -1; l2 < 4; ++l2)
                         {
                                 k3 = i5 + (i3 - 1) * k5;
                                 j3 = j5 + l2;
                                 i4 = j2 + (i3 - 1) * l5;
                                 flag = i3 == 0 || i3 == 3 || l2 == -1 || l2 == 3;

                                 /** change these blocks **/
                                 this.worldServerInstance.setBlock(k3, j3, i4, flag ? %frame-b% : block2, 0, 2);
                         }
                 }
                 for (i3 = 0; i3 < 4; ++i3)
                 {
                         for (l2 = -1; l2 < 4; ++l2)
                         {
                                 k3 = i5 + (i3 - 1) * k5;
                                 j3 = j5 + l2;
                                 i4 = j2 + (i3 - 1) * l5;
                                 this.worldServerInstance.notifyBlocksOfNeighborChange(k3, j3, i4, this.worldServerInstance.getBlock(k3, j3, i4));
                         }
                 }
         }
         return true;
}
/**
         * called periodically to remove out-of-date portal locations from the cache list. Argument par1 is a
         * WorldServer.getTotalWorldTime() value.
         */
public void removeStalePortalLocations(long par1)
{
         if (par1 % 100L == 0L)
         {
                 Iterator iterator = this.destinationCoordinateKeys.iterator();
                 long j = par1 - 600L;
                 while (iterator.hasNext())
                 {
                         Long olong = (Long)iterator.next();
                         PortalPosition portalposition = (PortalPosition)this.destinationCoordinateCache.getValueByKey(olong.longValue());
                         if (portalposition == null || portalposition.lastUpdateTime < j)
                         {
                                 iterator.remove();
                                 this.destinationCoordinateCache.remove(olong.longValue());
                         }
                 }
         }
}
}

public static class ModdedPortalPosition extends ChunkCoordinates
{
public long field_85087_d;
final ModdedTeleporter field_85088_e;
public ModdedPortalPosition(ModdedTeleporter tutorialTeleporter, int par2, int par3, int par4, long par5)
{
super(par2, par3, par4);
this.field_85088_e = tutorialTeleporter;
this.field_85087_d = par5;
}
}

public static class WorldProvider%name% extends WorldProvider
{
    /**
     * creates a new world chunk manager for WorldProvider
     */
    public void registerWorldChunkManager()
    {
		/*this.worldChunkMgr = new WorldChunkManager(this.worldObj.getSeed(), WorldType.DEFAULT){

			public BiomeGenBase getBiomeGenAt(int par1, int par2)
			    {
			        return BiomeGenBase.jungle;
    			}

			};*/
        this.worldChunkMgr = new WorldChunkManagerHell(%biome%, 0.5F, 0.0F);
        this.dimensionId = %did%;
    }

    public IChunkProvider createChunkGenerator()
	    {
	        return new ChunkProviderModded(this.worldObj, this.worldObj.getSeed()-%seeddata%, false);
    }

    @SideOnly(Side.CLIENT)

    /**
     * Return Vec3D with biome specific fog color
     */
    public Vec3 getFogColor(float par1, float par2)
    {
        return this.worldObj.getWorldVec3Pool().getVecFromPool(%kolor%);
    }

    /**
     * Creates the light to brightness table
     */
    protected void generateLightBrightnessTable()
    {
        float f = 0.1F;

        for (int i = 0; i <= 15; ++i)
        {
            float f1 = 1.0F - (float)i / 15.0F;
            this.lightBrightnessTable[i] = (1.0F - f1) / (f1 * 3.0F + 1.0F) * (1.0F - f) + f;
        }
    }



    /**
     * True if the player can respawn in this dimension (true = overworld, false = nether).
     */
    public boolean canRespawnHere()
    {
        return %resp%;
    }

    @SideOnly(Side.CLIENT)

    /**
     * Returns true if the given X,Z coordinate should show environmental fog.
     */
    public boolean doesXZShowFog(int par1, int par2)
    {
        return %fog%;
    }

    public boolean isSurfaceWorld()
	    {
	        return false;
    }

    /**
     * Returns the dimension's name, e.g. "The End", "Nether", or "Overworld".
     */
    public String getDimensionName()
    {
        return "%name%";
    }

    //bananana
    %worldData%
}

static class BlockModdedFire extends BlockFire
{
private int[] chanceToEncourageFire = new int[256];
private int[] abilityToCatchFire = new int[256];
@SideOnly(Side.CLIENT)
private Icon[] iconArray;
public BlockModdedFire()
{
super();
setTickRandomly(true);
}
public Icon getIcon(int par1, int par2)
{
return this.blockIcon;
}
public void initializeBlock()
{
this.abilityToCatchFire = Blocks.blockFlammability;
this.chanceToEncourageFire = Blocks.blockFireSpreadSpeed;
setBurnRate(Blocks.planks, 5, 20);
setBurnRate(Blocks.woodDoubleSlab, 5, 20);
setBurnRate(Blocks.woodSingleSlab, 5, 20);
setBurnRate(Blocks.fence, 5, 20);
setBurnRate(Blocks.stairsWoodOak, 5, 20);
setBurnRate(Blocks.stairsWoodBirch, 5, 20);
setBurnRate(Blocks.stairsWoodSpruce, 5, 20);
setBurnRate(Blocks.stairsWoodJungle, 5, 20);
setBurnRate(Blocks.wood, 5, 5);
setBurnRate(Blocks.leaves, 30, 60);
setBurnRate(Blocks.bookShelf, 30, 20);
setBurnRate(Blocks.tnt, 15, 100);
setBurnRate(Blocks.tallGrass, 60, 100);
setBurnRate(Blocks.cloth, 30, 60);
setBurnRate(Blocks.vine, 15, 100);
}
private void setBurnRate(int par1, int par2, int par3)
{
Blocks.setBurnProperties(par1, par2, par3);
}
public AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
{
return null;
}
public boolean isOpaqueCube()
{
return false;
}
public boolean renderAsNormalBlock()
{
return false;
}
public int getRenderType()
{
return 3;
}
public int quantityDropped(Random par1Random)
{
return 0;
}
public int tickRate(World par1World)
{
return 30;
}
public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
{
if (par1World.getGameRules().getGameRuleBooleanValue("doFireTick"))
{
Block base = Blocks.blocksList[par1World.getBlock(par2, par3 - 1, par4)];
boolean flag = (base != null) && (base.isFireSource(par1World, par2, par3 - 1, par4, par1World.getBlockMetadata(par2, par3 - 1, par4), ForgeDirection.UP));
if (!canPlaceBlockAt(par1World, par2, par3, par4))
{
par1World.setBlockToAir(par2, par3, par4);
}
if ((!flag) && (par1World.isRaining()) && ((par1World.canLightningStrikeAt(par2, par3, par4)) || (par1World.canLightningStrikeAt(par2 - 1, par3, par4)) || (par1World.canLightningStrikeAt(par2 + 1, par3, par4)) || (par1World.canLightningStrikeAt(par2, par3, par4 - 1)) || (par1World.canLightningStrikeAt(par2, par3, par4 + 1))))
{
par1World.setBlockToAir(par2, par3, par4);
}
else
{
int l = par1World.getBlockMetadata(par2, par3, par4);
if (l < 15)
{
par1World.setBlockMetadataWithNotify(par2, par3, par4, l + par5Random.nextInt(3) / 2, 4);
}
par1World.scheduleBlockUpdate(par2, par3, par4, this, tickRate(par1World) + par5Random.nextInt(10));
if ((!flag) && (!canNeighborBurn(par1World, par2, par3, par4)))
{
if ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) || (l > 3))
{
par1World.setBlockToAir(par2, par3, par4);
}
}
else if ((!flag) && (!canBlockCatchFire(par1World, par2, par3 - 1, par4, ForgeDirection.UP)) && (l == 15) && (par5Random.nextInt(4) == 0))
{
par1World.setBlockToAir(par2, par3, par4);
}
else
{
boolean flag1 = par1World.isBlockHighHumidity(par2, par3, par4);
byte b0 = 0;
if (flag1)
{
b0 = -50;
}
tryToCatchBlockOnFire(par1World, par2 + 1, par3, par4, 300 + b0, par5Random, l, ForgeDirection.WEST);
tryToCatchBlockOnFire(par1World, par2 - 1, par3, par4, 300 + b0, par5Random, l, ForgeDirection.EAST);
tryToCatchBlockOnFire(par1World, par2, par3 - 1, par4, 250 + b0, par5Random, l, ForgeDirection.UP);
tryToCatchBlockOnFire(par1World, par2, par3 + 1, par4, 250 + b0, par5Random, l, ForgeDirection.DOWN);
tryToCatchBlockOnFire(par1World, par2, par3, par4 - 1, 300 + b0, par5Random, l, ForgeDirection.SOUTH);
tryToCatchBlockOnFire(par1World, par2, par3, par4 + 1, 300 + b0, par5Random, l, ForgeDirection.NORTH);
for (int i1 = par2 - 1; i1 <= par2 + 1; i1++)
{
for (int j1 = par4 - 1; j1 <= par4 + 1; j1++)
{
for (int k1 = par3 - 1; k1 <= par3 + 4; k1++)
{
if ((i1 != par2) || (k1 != par3) || (j1 != par4))
{
int l1 = 100;
if (k1 > par3 + 1)
{
l1 += (k1 - (par3 + 1)) * 100;
}
int i2 = getChanceOfNeighborsEncouragingFire(par1World, i1, k1, j1);
if (i2 > 0)
{
int j2 = (i2 + 40 + par1World.difficultySetting * 7) / (l + 30);
if (flag1)
{
j2 /= 2;
}
if ((j2 > 0) && (par5Random.nextInt(l1) <= j2) && ((!par1World.isRaining()) || (!par1World.canLightningStrikeAt(i1, k1, j1))) && (!par1World.canLightningStrikeAt(i1 - 1, k1, par4)) && (!par1World.canLightningStrikeAt(i1 + 1, k1, j1)) && (!par1World.canLightningStrikeAt(i1, k1, j1 - 1)) && (!par1World.canLightningStrikeAt(i1, k1, j1 + 1)))
{
int k2 = l + par5Random.nextInt(5) / 4;
if (k2 > 15)
{
k2 = 15;
}
par1World.setBlock(i1, k1, j1, this, k2, 3);
}
}
}
}
}
}
}
}
}
}
public boolean func_82506_l() {
return true;
}
@Deprecated
private void tryToCatchBlockOnFire(World par1World, int par2, int par3, int par4, int par5, Random par6Random, int par7) {
tryToCatchBlockOnFire(par1World, par2, par3, par4, par5, par6Random, par7, ForgeDirection.UP);
}
private void tryToCatchBlockOnFire(World par1World, int par2, int par3, int par4, int par5, Random par6Random, int par7, ForgeDirection face) {
int j1 = 0;
Block block = Blocks.blocksList[par1World.getBlock(par2, par3, par4)];
if (block != null)
{
j1 = block.getFlammability(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), face);
}
if (par6Random.nextInt(par5) < j1)
{
boolean flag = par1World.getBlock(par2, par3, par4) == Blocks.tnt;
if ((par6Random.nextInt(par7 + 10) < 5) && (!par1World.canLightningStrikeAt(par2, par3, par4)))
{
int k1 = par7 + par6Random.nextInt(5) / 4;
if (k1 > 15)
{
k1 = 15;
}
par1World.setBlock(par2, par3, par4, this, k1, 3);
}
else
{
par1World.setBlockToAir(par2, par3, par4);
}
if (flag)
{
Blocks.tnt.onBlockDestroyedByPlayer(par1World, par2, par3, par4, 1);
}
}
}
private boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
{
return (canBlockCatchFire(par1World, par2 + 1, par3, par4, ForgeDirection.WEST)) ||
(canBlockCatchFire(par1World, par2 - 1, par3, par4, ForgeDirection.EAST)) ||
(canBlockCatchFire(par1World, par2, par3 - 1, par4, ForgeDirection.UP)) ||
(canBlockCatchFire(par1World, par2, par3 + 1, par4, ForgeDirection.DOWN)) ||
(canBlockCatchFire(par1World, par2, par3, par4 - 1, ForgeDirection.SOUTH)) ||
(canBlockCatchFire(par1World, par2, par3, par4 + 1, ForgeDirection.NORTH));
}
private int getChanceOfNeighborsEncouragingFire(World par1World, int par2, int par3, int par4)
{
byte b0 = 0;
if (!par1World.isAirBlock(par2, par3, par4))
{
return 0;
}
int l = getChanceToEncourageFire(par1World, par2 + 1, par3, par4, b0, ForgeDirection.WEST);
l = getChanceToEncourageFire(par1World, par2 - 1, par3, par4, l, ForgeDirection.EAST);
l = getChanceToEncourageFire(par1World, par2, par3 - 1, par4, l, ForgeDirection.UP);
l = getChanceToEncourageFire(par1World, par2, par3 + 1, par4, l, ForgeDirection.DOWN);
l = getChanceToEncourageFire(par1World, par2, par3, par4 - 1, l, ForgeDirection.SOUTH);
l = getChanceToEncourageFire(par1World, par2, par3, par4 + 1, l, ForgeDirection.NORTH);
return l;
}
public boolean isCollidable()
{
return false;
}
@Deprecated
public boolean canBlockCatchFire(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
{
return canBlockCatchFire(par1IBlockAccess, par2, par3, par4, ForgeDirection.UP);
}
@Deprecated
public int getChanceToEncourageFire(World par1World, int par2, int par3, int par4, int par5)
{
return getChanceToEncourageFire(par1World, par2, par3, par4, par5, ForgeDirection.UP);
}
public boolean canPlaceBlockAt(World par1World, int par2, int par3, int par4)
{
return (par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) || (canNeighborBurn(par1World, par2, par3, par4));
}
public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)
{
if ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) && (!canNeighborBurn(par1World, par2, par3, par4)))
{
par1World.setBlockToAir(par2, par3, par4);
}
}
public void onBlockAdded(World par1World, int par2, int par3, int par4)
{
/** Change these to your portal frame and Portal block **/
if ((par1World.getBlock(par2, par3 - 1, par4) != %frame-b%) || (!block2.tryToCreatePortal(par1World, par2, par3, par4)))
{
if ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) && (!canNeighborBurn(par1World, par2, par3, par4)))
{
par1World.setBlockToAir(par2, par3, par4);
}
else
{
par1World.scheduleBlockUpdate(par2, par3, par4, this, tickRate(par1World) + par1World.rand.nextInt(10));
par1World.setBlockToAir(par2, par3, par4);
}
}
}
@SideOnly(Side.CLIENT)
public void randomDisplayTick(World par1World, int par2, int par3, int par4, Random par5Random)
{
if (par5Random.nextInt(24) == 0)
{
par1World.playSound(par2 + 0.5F, par3 + 0.5F, par4 + 0.5F, "fire.fire", 1.0F + par5Random.nextFloat(), par5Random.nextFloat() * 0.7F + 0.3F, false);
}
if ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) && (!ModdedFire.canBlockCatchFire(par1World, par2, par3 - 1, par4, ForgeDirection.UP)))
{
if (ModdedFire.canBlockCatchFire(par1World, par2 - 1, par3, par4, ForgeDirection.EAST))
{
for (int l = 0; l < 2; l++)
{
float f = par2 + par5Random.nextFloat() * 0.1F;
float f1 = par3 + par5Random.nextFloat();
float f2 = par4 + par5Random.nextFloat();
par1World.spawnParticle("largesmoke", f, f1, f2, 0.0D, 0.0D, 0.0D);
}
}
if (ModdedFire.canBlockCatchFire(par1World, par2 + 1, par3, par4, ForgeDirection.WEST))
{
for (int l = 0; l < 2; l++)
{
float f = par2 + 1 - par5Random.nextFloat() * 0.1F;
float f1 = par3 + par5Random.nextFloat();
float f2 = par4 + par5Random.nextFloat();
par1World.spawnParticle("largesmoke", f, f1, f2, 0.0D, 0.0D, 0.0D);
}
}
if (ModdedFire.canBlockCatchFire(par1World, par2, par3, par4 - 1, ForgeDirection.SOUTH))
{
for (int l = 0; l < 2; l++)
{
float f = par2 + par5Random.nextFloat();
float f1 = par3 + par5Random.nextFloat();
float f2 = par4 + par5Random.nextFloat() * 0.1F;
par1World.spawnParticle("largesmoke", f, f1, f2, 0.0D, 0.0D, 0.0D);
}
}
if (ModdedFire.canBlockCatchFire(par1World, par2, par3, par4 + 1, ForgeDirection.NORTH))
{
for (int l = 0; l < 2; l++)
{
float f = par2 + par5Random.nextFloat();
float f1 = par3 + par5Random.nextFloat();
float f2 = par4 + 1 - par5Random.nextFloat() * 0.1F;
par1World.spawnParticle("largesmoke", f, f1, f2, 0.0D, 0.0D, 0.0D);
}
}
if (ModdedFire.canBlockCatchFire(par1World, par2, par3 + 1, par4, ForgeDirection.DOWN))
{
for (int l = 0; l < 2; l++)
{
float f = par2 + par5Random.nextFloat();
float f1 = par3 + 1 - par5Random.nextFloat() * 0.1F;
float f2 = par4 + par5Random.nextFloat();
par1World.spawnParticle("largesmoke", f, f1, f2, 0.0D, 0.0D, 0.0D);
}
}
}
else
{
for (int l = 0; l < 3; l++)
{
float f = par2 + par5Random.nextFloat();
float f1 = par3 + par5Random.nextFloat() * 0.5F + 0.5F;
float f2 = par4 + par5Random.nextFloat();
par1World.spawnParticle("largesmoke", f, f1, f2, 0.0D, 0.0D, 0.0D);
}
}
}
public boolean canBlockCatchFire(IBlockAccess world, int x, int y, int z, ForgeDirection face)
{
Block block = Blocks.blocksList[world.getBlock(x, y, z)];
if (block != null)
{
return block.isFlammable(world, x, y, z, world.getBlockMetadata(x, y, z), face);
}
return false;
}
public int getChanceToEncourageFire(World world, int x, int y, int z, int oldChance, ForgeDirection face)
{
int newChance = 0;
Block block = Blocks.blocksList[world.getBlock(x, y, z)];
if (block != null)
{
newChance = block.getFireSpreadSpeed(world, x, y, z, world.getBlockMetadata(x, y, z), face);
}
return newChance > oldChance ? newChance : oldChance;
}
/** registers Icons, set textures here **/
@SideOnly(Side.CLIENT)
public void registerIcons(IconRegister par1IconRegister)
{
this.iconArray = new Icon[] { par1IconRegister.registerIcon("%texture-portal%"), par1IconRegister.registerIcon("%texture-portal%") };
}
@SideOnly(Side.CLIENT)
public Icon getFireIcon(int par1) {
return this.iconArray[par1];
}
@SideOnly(Side.CLIENT)
public Icon getBlockTextureFromSideAndMetadata(int par1, int par2)
{
return this.iconArray[0];
}
}


static class Itemblock extends Item
{
public Itemblock()
{
super();
this.maxStackSize = 1;
setMaxDamage(64);
setCreativeTab(CreativeTabs.tabTools);
}
public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
{
if (par7 == 0)
{
par5--;
}
if (par7 == 1)
{
par5++;
}
if (par7 == 2)
{
par6--;
}
if (par7 == 3)
{
par6++;
}
if (par7 == 4)
{
par4--;
}
if (par7 == 5)
{
par4++;
}
if (!par2EntityPlayer.canPlayerEdit(par4, par5, par6, par7, par1ItemStack))
{
return false;
}
int i1 = par3World.getBlock(par4, par5, par6);
if (i1 == 0)
{
par3World.playSoundEffect(par4 + 0.5D, par5 + 0.5D, par6 + 0.5D, "fire.ignite", 1.0F, itemRand.nextFloat() * 0.4F + 0.8F);
/** replace with your fire block **/
par3World.setBlock(par4, par5, par6, ModdedFire);
}
par1ItemStack.damageItem(1, par2EntityPlayer);
return true;
}
}

%strucutreCodes%

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

%chunkprovider%

}
